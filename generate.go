//go:build ignore

// This program generates data.go by downloading zip code data.
// Run with: go generate
package main

import (
	"bytes"
	"compress/bzip2"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"sort"
	"text/template"
)

const dataURL = "https://raw.githubusercontent.com/seanpianka/Zipcodes/master/zipcodes/zips.json.bz2"

type zipEntry struct {
	ZipCode  string  `json:"zip_code"`
	Timezone *string `json:"timezone"`
}

type entry struct {
	Zip string
	TZ  string
}

var tmpl = template.Must(template.New("data").Parse(`// Code generated by go generate; DO NOT EDIT.
// Source: https://github.com/seanpianka/Zipcodes (MIT License)

package ziptz

var zipToTimezone = map[string]string{
{{- range . }}
	"{{ .Zip }}": "{{ .TZ }}",
{{- end }}
}
`))

func main() {
	fmt.Println("Downloading zip code data...")
	resp, err := http.Get(dataURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to download: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Fprintf(os.Stderr, "unexpected status: %s\n", resp.Status)
		os.Exit(1)
	}

	fmt.Println("Decompressing...")
	bzReader := bzip2.NewReader(resp.Body)
	data, err := io.ReadAll(bzReader)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to decompress: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Parsing JSON...")
	var entries []zipEntry
	if err := json.Unmarshal(data, &entries); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse JSON: %v\n", err)
		os.Exit(1)
	}

	// Build map, filtering out null timezones
	zipMap := make(map[string]string)
	for _, e := range entries {
		if e.Timezone != nil && *e.Timezone != "" {
			zipMap[e.ZipCode] = *e.Timezone
		}
	}

	// Sort keys for deterministic output
	keys := make([]string, 0, len(zipMap))
	for k := range zipMap {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Create sorted slice for template
	sorted := make([]entry, 0, len(keys))
	for _, k := range keys {
		sorted = append(sorted, entry{Zip: k, TZ: zipMap[k]})
	}

	fmt.Println("Generating data.go...")
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, sorted); err != nil {
		fmt.Fprintf(os.Stderr, "failed to execute template: %v\n", err)
		os.Exit(1)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to format: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile("data.go", formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Done! Generated %d zip code entries.\n", len(zipMap))
}
